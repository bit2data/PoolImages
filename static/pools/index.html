<!DOCTYPE html>
<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

<title>Prediction</title>

<style>
.wrapper {
  touch-action: none;
}

.imgContainer {
  display: inline-block;
  position: relative;
  width: 400px;
  height: 400px;
  padding: 0px;
}
</style>
</head><body>

<p>Human vs Predictions</p>
<div class="wrapper">
    <div class="imgContainer">
      <img id="baseImage" 
      alt="Image alt text" style="position: absolute; left: 0; top: 0; padding: 0px; z-index: 0;">
      <canvas id="bottomCanvas" class="bottomLayer" width="400" height="400"
      style="position: absolute; left: 0; top: 0; padding: 0px; z-index: 1;"></canvas>
    </div>   
    <div class="imgContainer">
      <img id="baseImageR" 
      alt="Image alt text" style="position: absolute; left: 0; top: 0; padding: 0px; z-index: 0;">
      <canvas id="bottomCanvasR" class="bottomLayer" width="400" height="400"
      style="position: absolute; left: 0; top: 0; padding: 0px; z-index: 1;"></canvas>
    </div>
</div>
<div>
  <button id="prevBtn" class="buttonStyle">&larr; Prev</button>
  <input type="text" id="filename">
  <button onclick=openEditor()>Edit</button>
  <input type="text" id="note">
  <button id="nextBtn" class="buttonStyle">Next &rarr;</button>
</div>
<script>
var pages = [];//JSON get fetched and mages are populated on load
//navigation logic
var pageIndex = -1;

function currPage() {
  return pages[pageIndex];
}

function next() {
  pageIndex += 1;
  return navigate();
}

//BUG: going back beyond page=0, going forward skips page=0 to page=1
function prev() {
  //pageIndex -= 1;
  //return navigate();
  return history.back();
}

function navigate() {
  var url = '?page=' + pageIndex;
  history.pushState(pageIndex, null, url);
  return renderPage(currPage());
}

window.onpopstate = function (e) {
  console.log('restore: ', e.state);
  if (e.state != null) pageIndex = e.state;
  return renderPage(currPage());
};

function openEditor() {
  const jpath = currPage().json_path;
  let tokens = jpath.split('/');
  console.log(tokens, tokens[4], tokens[5]);
  const where = `/static/pools/pool_edit.html?p=${tokens[4]}/${tokens[5]}`;
  console.log('go to', where);
  location.replace(where);
}
// end of navigation logic

// {} -> Bool
function renderPage (page) {
  if (!page) {
    alert('nothing to display')
    return false;
  }
  renderMapImage(page.image_path);
  var ctx = document.getElementById("bottomCanvas").getContext('2d');
  renderPoolMarks(page.rects, ctx);
  return true;
}

// URL -> Bool
function renderMapImage(src) {
  var img, imgR;
  img = document.getElementById('baseImage');
  img.src = src;
  img.onload = function () {
    console.log('width', img.width);
    console.log('height', img.height);
  };
  imgR = document.getElementById('baseImageR')
  imgR.src = src;
  imgR.onload = function () {
    //load predictions and mark em
    pred_json_path = src.replace('images', 'predictions').replace('jpg', 'json');
    fetch(pred_json_path)
    .then(response => response.json())
    .then(pred => {
      console.log(pred);
      var ctx = document.getElementById('bottomCanvasR').getContext('2d');
      clear(ctx);
      pred.boxes.forEach((box, i) => {
        console.log(box, i);
        var score = pred.scores[i];
        console.log('score', score);
        var rgba = "rgba(255,0,0,"+(score * score)+")";
        if (score < 0.5) {
          console.log('rgba', rgba);
          return console.log('skip low score', score);
        }
        var x, y, w, h;
        x = box[0];
        y = box[1];
        w = box[2] - x;
        h = box[3] - y;
 	      ctx.fillStyle = rgba;
     	  ctx.strokeStyle = rgba;
    	  ctx.font = "bold 16px Arial" ;
        ctx.strokeRect(x, y, w, h);
      });
    });
  };

  var filename = src.split('/').pop();
  document.getElementById('filename').value = filename;

  return true;
}

//[{}] ctx -> Int
function renderPoolMarks(rects, ctx) {
  //var ctx = bottomCanvas.getContext('2d');
  clear(ctx);
  rects.forEach(rect => {
    renderPoolMark(rect, ctx);
  });
  document.getElementById('note').value = rects.length + ' pools marked';
  return rects.length;
}

// {} ctx -> Int
function renderPoolMark(rect, ctx) {
  if (!rect) return 0;// just clear the top
 	ctx.fillStyle = "rgba(255`,165,0,1)";
 	ctx.strokeStyle = "rgba(255,165,0,1)";
	ctx.font = "bold 16px Arial" ;
  ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
  return 1;
}

// ctx -> True 
function clear(ctx) {
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
  return true;
}

//get DATA and get things rolling
window.onload = function () {
  console.log("onload");

  var nextBtn = document.getElementById("nextBtn");
  var prevBtn = document.getElementById("prevBtn");
  nextBtn.addEventListener('click', next, false);
  prevBtn.addEventListener('click', prev, false);
  document.addEventListener('keydown', event => {
    // if alt is pressed, skip
    if (event.altKey) return false;
    if (event.code === 'ArrowRight') return nextBtn.click();
    if (event.code === 'ArrowLeft') return prevBtn.click();
  });

  //fetching data
  fetch('/imgdata/')
  .then(response => response.json())
  .then(items => {
    pages = items;

    var urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('page')) {
      var pageNum = Number(urlParams.get('page'));
      if (!isNaN(pageNum)) {
        pageIndex = pageNum;
        return renderPage(currPage());
      }
    } 
    return nextBtn.click();
  });//end fetching data and rendering
};//onload
</script>
</body>
</html>