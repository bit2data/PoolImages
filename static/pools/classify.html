<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Classify</title>

<style>
#map {
  /* max size for free maps is 640 */
  width: 640px;
  height: 600px;
}
</style>
</head><body>

<div class="row">

  <div class="col-md-8">
    <div id="map">
    </div>    
  </div>

  <div class="col-md-4">      
      <p>Classifier created at <span id="classifier-ts"></span></p>
  </div>

</div>

<script src="mercata.js"></script>

<script>
var map;// dynamic v3 not static

// LatLng -> Point
var fromLatLngToPixelCoordinates = function (latLng) {
  var numTiles = 1 << map.getZoom();
  var projection = new MercatorProjection();
  var worldCoordinate = projection.fromLatLngToPoint(latLng);
  var pixelCoordinate = new google.maps.Point(
      Math.floor(worldCoordinate.x * numTiles),
      Math.floor(worldCoordinate.y * numTiles));

  return pixelCoordinate;
};

// Point -> LatLng
var fromPixelCoordinatesToLatLng = function (point) {
  var numTiles = 1 << map.getZoom();
  var projection = new MercatorProjection();

  var worldCoordinate = new google.maps.Point(point.x * 1.0 / numTiles, point.y * 1.0 / numTiles);
  return projection.fromPointToLatLng(worldCoordinate);
};

// Bounds -> {x:int, y:int, w:int, h:int}
var fromBoundsToXYWH = function (bounds) {

    var sw = bounds.getSouthWest();
    var ne = bounds.getNorthEast();
    var nw = new google.maps.LatLng(ne.lat(), sw.lng());
    var se = new google.maps.LatLng(sw.lat(), ne.lng());

    var pixelCoordinates = {
      nw: fromLatLngToPixelCoordinates(nw),
      ne: fromLatLngToPixelCoordinates(ne),
      sw: fromLatLngToPixelCoordinates(sw),
      se: fromLatLngToPixelCoordinates(se)
    };

    return {
      x: pixelCoordinates.nw.x,
      y: pixelCoordinates.nw.y,
      w: pixelCoordinates.ne.x - pixelCoordinates.nw.x, 
      h: pixelCoordinates.se.y - pixelCoordinates.ne.y
    };
};

// {x: y: w: h:} -> Bounds
var fromXYWHToBounds = function (xywh) {
  var topUpperLeft = fromBoundsToXYWH(map.getBounds());

  //in world/pixel coordinate
  var sw = {
    x: topUpperLeft.x + xywh.x,
    y: topUpperLeft.y + xywh.y + xywh.h
  };

  var ne = {
    x: topUpperLeft.x + xywh.x + xywh.w,
    y: topUpperLeft.y + xywh.y 
  };

  return new google.maps.LatLngBounds(fromPixelCoordinatesToLatLng(sw), fromPixelCoordinatesToLatLng(ne));
};

// [Rect] -> [(x y w h)] where x and y are from Top Left corner aka (0, 0)
var fromRectsToXYWHs = function (rects) {

  var topUpperLeft = fromBoundsToXYWH(map.getBounds());

  var proc = function (rect) {
    var xywh = fromBoundsToXYWH(rect.getBounds());

    xywh.x -= topUpperLeft.x;
    xywh.y -= topUpperLeft.y;

    return xywh;
  };

  return R.map(proc, rects);
};

// Point Int -> Bounds
// rectangle bounds (sw, ne) around (lat, lng)
var calcBounds = function (center,size) {
  var n=google.maps.geometry.spherical.computeOffset(center,size.height/2,0).lat(),
     s=google.maps.geometry.spherical.computeOffset(center,size.height/2,180).lat(),
     e=google.maps.geometry.spherical.computeOffset(center,size.width/2,90).lng(),
     w=google.maps.geometry.spherical.computeOffset(center,size.width/2,270).lng();

     return new google.maps.LatLngBounds(new google.maps.LatLng(s,w), new google.maps.LatLng(n,e));
};

// Map Bounds FirebaseRef Color -> Rectangle
// represent the classified region with a Box, with different color
var placeTempRect = function (map, bounds, color) {

  var rectangle = new google.maps.Rectangle({
    strokeColor: color,
    strokeOpacity: 0.8,
    strokeWeight: 1,
    fillColor: '#FFFFFF',
    fillOpacity: 0.0,
    map: map,
    bounds: bounds
  });

  return rectangle;
};

var qry = function (lat, lng, width, height, zoom) {
  var s = "lat="+lat+"&lng="+lng+"&zoom="+zoom+"&width="+width+"&height="+height;
  return s;
};

//https://developers.google.com/maps/documentation/javascript/examples/control-custom-state
class CenterControl {
  constructor(controlDiv, map) {

  // Set CSS for the control border
  var controlUI = document.createElement('div');
  controlUI.style.backgroundColor = '#fff';
  controlUI.style.border = '2px solid #fff';
  controlUI.style.borderRadius = '3px';
  controlUI.style.boxShadow = '0 2px 6px rgba(0,0,0,.3)';
  controlUI.style.cursor = 'pointer';
  controlUI.style.marginBottom = '22px';
  controlUI.style.textAlign = 'center';
  controlUI.title = 'Click to recenter the map';
  controlDiv.appendChild(controlUI);

  // Set CSS for the control interior
  var controlText = document.createElement('div');
  controlText.style.color = 'rgb(25,25,25)';
  controlText.style.fontFamily = 'Roboto,Arial,sans-serif';
  controlText.style.fontSize = '16px';
  controlText.style.lineHeight = '38px';
  controlText.style.paddingLeft = '5px';
  controlText.style.paddingRight = '5px';
  controlText.innerHTML = 'Detect Pools';
  controlUI.appendChild(controlText);

  google.maps.event.addDomListener(controlUI, 'click', function() {

    var latLng = map.getCenter();
    var zoom = map.getZoom();

    // server should send back [{x: y: w: h:}]
    // draw recommendation using those...
    fetch('/detect/?'+qry(latLng.lat(), latLng.lng(), 640, 600, zoom))
    .then(response => response.json())
    .then(data => {
      data.forEach(xywh => {
        var bounds = fromXYWHToBounds(xywh);
        return placeTempRect(map, bounds, "#FF0000");
      });
      console.log("Predictions:", data);
    });//fetch

  });
  }
}

var initMap = function () {
 
  map = new google.maps.Map(document.getElementById('map'), {
    zoom: 18,
    center: new google.maps.LatLng(43.35975, -79.77),
    mapTypeId: google.maps.MapTypeId.SATELLITE,
    disableDefaultUI: true,
    zoomControl: true,
    streetViewControl: false
  });

  // Create the DIV to hold the control and
  // call the CenterControl() constructor passing
  // in this DIV.
  var centerControlDiv = document.createElement('div');
  var centerControl = new CenterControl(centerControlDiv, map);

  centerControlDiv.index = 1;
  map.controls[google.maps.ControlPosition.TOP_RIGHT].push(centerControlDiv);

  return "done";
};//initMap

</script>
    
<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDJHNZPgCpEYbDmr_dn6Y66U0jXxzeeErQ&callback=initMap" async> </script>

</body></html>
